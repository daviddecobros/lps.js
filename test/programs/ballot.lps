% By BK, modified by MC:
% single ballot per program instance, added pre conditions and method names as in Solidity original

% Original File: https://bitbucket.org/lpsmasters/lps_corner/src/06b0de6227f751547e8d25937c05fa30208e45f5/examples/forTesting/ballotTest.pl?at=master
% Translated by Sam Yong

maxTime(15).
cycleInterval(200).

events([
  ballot(_Chairman, _Proposals),
  giveRightToVote(_Chairman, _Voter),
  delegate(_FromVoter, _ToVoter),
  vote(_Voter, _Candidate)
]).

fluents([
  chairman(_Chairman),
  voter(_Voter, _Weight),
  voted(_Voter, _Candidate),
  delegateOf(_Voter,_D),
  voteCount(_Candidate, _Votes),
  won(_Candidate)
]).

action(selectCandidate(_Candidate)).
action(initiateVoting(_Candidate)).

initiates(ballot(Chairman, _Proposals), voter(Chairman, 1)).
initiates(ballot(Chairman, _Proposals), chairman(Chairman)).
initiates(ballot(_Chairman, Proposals), voteCount(Candidate, 0), [member(Candidate, Proposals)]).

<- ballot(_, _, T1, T2), voteCount(_, _, T1).

initiates(giveRightToVote(Chairman, Voter), voter(Voter, 1), [chairman(Chairman, T1), not voter(Voter, _, T1)]).

% The next clause deals with the case a delegate has already voted when a delegation is made:
updates(
  delegate(Voter1, Voter2),
  voteCount(Candidate, OldVotes),
  voteCount(Candidate, OldVotes + N),
  [
    delegateOf(Voter2, Voter3, T),
    voted(Voter3, Candidate, T),
    voter(Voter1, N, T)
  ]
).

updates(delegate(Voter1, Voter2), voter(Voter1, Old), voter(Voter1, 0)).
updates(delegate(Voter1, Voter2), voter(Voter3, Old), voter(Voter3, N1 + Old), [
  delegateOf(Voter2, Voter3, T1),
  voter(Voter1, N1, T1)
]).

initiates(delegate(Voter1, Voter2), voted(Voter1, delegated(Voter2))).

% deal with delegate chains
delegateOf(Voter, D, T) <-
  voted(Voter, delegated(DD), T),
  delegateOf(DD, D, T).
delegateOf(Voter, Voter, T) <-
  not voted(Voter, delegated(_), T).

/* This allows only one delegation to Voter2 at a time.
 * We may need to extend LPS to have several delegations simultaneously. */
<- delegate(Voter1, Voter, T), delegate(Voter2, Voter, T), Voter1 != Voter2.

/* This allows only one weighted vote for the same candidate at a time.
 * We may need to extend LPS to have several votes for the same candidate simultaneously.*/
<- delegate(Voter, _, T, T2), voted(Voter, _, T).
<- delegate(Voter, Voter, _, _).
<- delegate(Voter, Voter1, T1, T2), delegate(Voter, Voter2, T1, T2), Voter1 != Voter2.

% prevent delegation loops:
<- delegate(Voter1, Voter2, T1, T2), delegateOf(Voter2, Voter1, T1).

intitates(vote(Voter, Candidate), voted(Voter, Candidate)).

/* This allows only one weighted vote for the same candidate at a time.
 * We need to extend LPS to have several votes for the same candidate simultaneously. */
updates(vote(Voter, Candidate), voteCount(Candidate, OldVotes), voteCount(Candidate, OldVotes + Weight), [voter(Voter, Weight, T)]).
  
% no two voters can vote in the same cycle
<- vote(Voter1, Candidate, T1, T2), vote(Voter2, Candidate, T1, T2), Voter1 != Voter2.
% a voter cannot vote if the voter has already voted
<- vote(Voter, _, T1, T2), voted(Voter, _, T1).

<- vote(Voter, Candidate1, T1, T2), vote(Voter, Candidate2, T1, T2), Candidate1 != Candidate2.

initiates(vote(Voter, Candidate), voted(Voter, Candidate)).

% winningProposal(Candidate, N, T) <-
%   findall(pair(N, Candidate), voteCount(Candidate, N, T), L),
%   sort(L, SL),
%   append(_, pair(N, Candidate), SL).
% 
% winningProposal(_Candidate, 4, _) -> selectCandidate(_Candate, T1).
